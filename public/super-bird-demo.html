<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>超级鸟类预览演示 - Belly (271)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            width: 100% !important;
            height: 100% !important;
            display: block !important;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            font-size: 16px;
            z-index: 1000;
        }

        #cameraPanel {
            position: absolute;
            top: 60px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            display: none;
            z-index: 200;
            min-width: 200px;
        }

    </style>
</head>
<body>
    <div id="info">
        <strong>超级鸟类预览演示</strong><br>
        Belly (271).glb - 2x 放大<br>
        鼠标拖拽旋转，滚轮缩放
    </div>

    <div id="loading">正在加载模型...</div>

    <div id="cameraPanel">
        <strong>镜头位置信息</strong><br>
        <div id="cameraInfo">按 '2' 键显示/隐藏此面板</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "../three.js-dev/build/three.module.js",
            "three/addons/": "../three.js-dev/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { HDRLoader } from '../src/loaders/HDRLoader.js';

        let camera, scene, renderer, controls;
        let bellyModel = null;
        let sphereModel = null;
        let ambientLight, keyLight, fillLight, spotLight;
        let renderTarget = null;
        let postProcessingMaterial = null;

        init();
        animate();

        function init() {
            // 创建场景
            scene = new THREE.Scene();

            // 创建相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(5.40, -0.09, 11.61);
            camera.lookAt(0, 0, 0);

            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; // 基础曝光设为1.0，后期处理控制最终曝光
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            console.log('初始曝光值:', renderer.toneMappingExposure);
            document.body.appendChild(renderer.domElement);

            // 创建渲染目标用于后期处理
            renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                format: THREE.RGBAFormat,
                type: THREE.UnsignedByteType,
                encoding: THREE.sRGBEncoding
            });

            // 创建后期处理材质
            const postProcessingShader = {
                uniforms: {
                    tDiffuse: { value: null },
                    brightness: { value: 0.12 },
                    contrast: { value: 0.95},
                    saturation: { value: 1.05 },
                    exposure: { value: 0.85 },
                    colorBalance: { value: new THREE.Vector3(1.05, 1.0, 0.95) } // RGB色彩平衡：增加红，保持绿，降低蓝
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float brightness;
                    uniform float contrast;
                    uniform float saturation;
                    uniform float exposure;
                    uniform vec3 colorBalance;
                    varying vec2 vUv;

                    void main() {
                        vec4 color = texture2D(tDiffuse, vUv);

                        // 曝光调整
                        color.rgb *= exposure;

                        // 色彩平衡调整（中和偏蓝色调）
                        color.r *= colorBalance.r; // 增加红色
                        color.g *= colorBalance.g; // 保持绿色
                        color.b *= colorBalance.b; // 降低蓝色

                        // 亮度调整
                        color.rgb += brightness;

                        // 对比度调整
                        color.rgb = (color.rgb - 0.5) * contrast + 0.5;

                        // 饱和度调整
                        float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                        color.rgb = mix(vec3(luminance), color.rgb, saturation);

                        gl_FragColor = color;
                    }
                `
            };

            postProcessingMaterial = new THREE.ShaderMaterial(postProcessingShader);

            // 创建全屏四边形
            const geometry = new THREE.PlaneGeometry(2, 2);
            const mesh = new THREE.Mesh(geometry, postProcessingMaterial);
            const scenePostProcessing = new THREE.Scene();
            scenePostProcessing.add(mesh);

            // 存储后期处理场景
            window.scenePostProcessing = scenePostProcessing;
            window.postProcessingCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            // 创建控制器
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enableRotate = true;
            controls.enablePan = false;
            controls.minDistance = 3;
            controls.maxDistance = 20;
            controls.maxPolarAngle = Math.PI;

            // 设置控制器目标点（相机看向的点）
            controls.target.set(0, 0, 0);
            controls.update();

            // 加载HDR环境
            const hdrLoader = new HDRLoader();
            hdrLoader.load('./hdr/whitebox.hdr', (hdrTexture) => {
                hdrTexture.mapping = THREE.EquirectangularReflectionMapping;

                // 设置背景和环境
                scene.background = hdrTexture;

                // 创建PMREM环境贴图用于材质照明
                const pmremGenerator = new THREE.PMREMGenerator(renderer);
                pmremGenerator.compileEquirectangularShader();
                const envMap = pmremGenerator.fromEquirectangular(hdrTexture).texture;
                scene.environment = envMap;

                console.log('HDR环境加载完成');

                // 加载belly模型
                loadBellyModel();

            }, (progress) => {
                console.log('HDR加载进度:', progress);
            }, (error) => {
                console.warn('HDR加载失败，使用默认背景:', error);
                scene.background = new THREE.Color(0x333333);

                // 即使HDR失败也继续加载模型
                loadBellyModel();
            });

            // 添加光照系统
            setupLighting();

            // 创建球体预览模型
            createSpherePreview();


            // 添加按键监听
            window.addEventListener('keydown', onKeyDown);

            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);
        }

        function setupLighting() {
            // 环境光 - 室内白炽灯暖色调
            ambientLight = new THREE.AmbientLight(0xFFF4E5, 0.6);
            scene.add(ambientLight);

            // 主关键光 - 室内白炽灯暖色调
            keyLight = new THREE.DirectionalLight(0xFFF4E5, 1);
            keyLight.position.set(5, 10, 5);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.set(2048, 2048);
            keyLight.shadow.radius = 4;
            keyLight.shadow.camera.near = 0.1;
            keyLight.shadow.camera.far = 50;
            keyLight.shadow.camera.left = -15;
            keyLight.shadow.camera.right = 15;
            keyLight.shadow.camera.top = 15;
            keyLight.shadow.camera.bottom = -15;
            scene.add(keyLight);

            // 填充光 - 室内白炽灯暖色调
            fillLight = new THREE.HemisphereLight(0xFFF4E5, 0xD4B08A, 0.15);
            scene.add(fillLight);

            // 聚光灯 - 室内白炽灯暖色调
            spotLight = new THREE.SpotLight(0xFFF4E5, 20.0);
            spotLight.position.set(4, 10, 0); // 上方中心位置
            spotLight.target.position.set(0, 0, 0); // 瞄准belly模型中心
            spotLight.angle = Math.PI / 11; // 缩小到22.5度锥角，更聚焦
            spotLight.penumbra = 0.05; // 减小边缘柔和度，产生更锐利的边界
            spotLight.decay = 1; // 减小衰减，让光更均匀
            spotLight.distance = 30; // 缩短有效距离
            spotLight.castShadow = true;
            spotLight.shadow.mapSize.width = 2048;
            spotLight.shadow.mapSize.height = 2048;
            spotLight.shadow.camera.near = 1;
            spotLight.shadow.camera.far = 20;
            spotLight.shadow.bias = -0.0001;
            scene.add(spotLight);
            scene.add(spotLight.target); // 必须添加target到场景
        }

        function onKeyDown(event) {
            if (event.key === '2') {
                const panel = document.getElementById('cameraPanel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            }
        }

        function createSpherePreview() {
            // 创建球体几何体
            const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                roughness: 0.1,
                metalness: 0.9
            });

            sphereModel = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphereModel.position.set(-3, 0, 0); // 放在belly模型左侧
            sphereModel.castShadow = true;
            sphereModel.receiveShadow = true;

            scene.add(sphereModel);
            console.log('球体预览模型已创建');
        }






        function loadBellyModel() {
            const loader = new GLTFLoader();
            loader.load('./models/bird_components/belly/belly (271).glb', function(gltf) {
                bellyModel = gltf.scene;

                // 放大2倍
                bellyModel.scale.set(2, 2, 2);

                // 放在场景中心
                bellyModel.position.set(0, 0, 0);

                // 处理材质
                bellyModel.traverse((child) => {
                    if (child.isMesh && child.material) {
                        const materials = Array.isArray(child.material) ? child.material : [child.material];
                        const newMaterials = [];

                        materials.forEach(material => {
                            try {
                                if (!(material instanceof THREE.MeshStandardMaterial)) {
                                    const newMaterial = new THREE.MeshStandardMaterial();
                                    if (material.color && material.color.isColor) {
                                        newMaterial.color.copy(material.color);
                                    } else {
                                        newMaterial.color.setHex(0x888888);
                                    }
                                    if (material.map) newMaterial.map = material.map;
                                    if (material.normalMap) newMaterial.normalMap = material.normalMap;
                                    if (material.roughnessMap) newMaterial.roughnessMap = material.roughnessMap;
                                    if (material.metalnessMap) newMaterial.metalnessMap = material.metalnessMap;

                                    // 设置PBR属性
                                    newMaterial.roughness = 0.1;
                                    newMaterial.metalness = 0.9;

                                    newMaterials.push(newMaterial);
                                } else {
                                    newMaterials.push(material);
                                }
                            } catch (error) {
                                console.warn('材质处理失败，使用默认材质:', error);
                                newMaterials.push(new THREE.MeshStandardMaterial({
                                    color: 0x888888,
                                    roughness: 0.1,
                                    metalness: 0.9
                                }));
                            }
                        });

                        child.material = newMaterials.length === 1 ? newMaterials[0] : newMaterials;
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });

                // 添加到场景
                scene.add(bellyModel);

                console.log('Belly (271) 模型加载完成，2倍大小显示在场景中心');

                // 隐藏加载提示
                const loadingDiv = document.getElementById('loading');
                if (loadingDiv) {
                    loadingDiv.style.display = 'none';
                }

                render();

            }, (progress) => {
                console.log('模型加载进度:', progress);
            }, function(error) {
                console.error('加载belly模型失败:', error);
                const loadingDiv = document.getElementById('loading');
                if (loadingDiv) {
                    loadingDiv.textContent = '加载失败: ' + error.message;
                }
            });
        }


        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            render();
        }

        function updateCameraInfo() {
            if (camera) {
                const position = camera.position;
                const rotation = camera.rotation;

                const cameraInfo = document.getElementById('cameraInfo');
                if (cameraInfo) {
                    cameraInfo.innerHTML = `
                        <strong>位置 (Position):</strong><br>
                        X: ${position.x.toFixed(2)}<br>
                        Y: ${position.y.toFixed(2)}<br>
                        Z: ${position.z.toFixed(2)}<br><br>
                        <strong>旋转 (Rotation):</strong><br>
                        X: ${(rotation.x * 180 / Math.PI).toFixed(1)}°<br>
                        Y: ${(rotation.y * 180 / Math.PI).toFixed(1)}°<br>
                        Z: ${(rotation.z * 180 / Math.PI).toFixed(1)}°<br><br>
                        <strong>距离 (Distance):</strong><br>
                        ${position.length().toFixed(2)}
                    `;
                }
            }
        }

        function render() {
            // 更新相机信息显示
            updateCameraInfo();

            if (renderer && renderTarget && postProcessingMaterial) {
                // 第一遍渲染到纹理（应用tone mapping）
                renderer.setRenderTarget(renderTarget);
                renderer.render(scene, camera);

                // 第二遍渲染后期处理效果
                renderer.setRenderTarget(null);
                postProcessingMaterial.uniforms.tDiffuse.value = renderTarget.texture;
                renderer.render(window.scenePostProcessing, window.postProcessingCamera);
            } else if (renderer) {
                // 如果后期处理未准备好，直接渲染（应用tone mapping）
                renderer.render(scene, camera);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // 重新创建渲染目标
            if (renderTarget) {
                renderTarget.dispose();
            }
            renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

            render();
        }
    </script>
</body>
</html>