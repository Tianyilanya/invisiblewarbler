<!DOCTYPE html>
<html lang="en">
<head>
    <title>Invisible Warbler - Scene Test</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
            background: #000;
            font-family: monospace;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "./three.js-dev/build/three.module.js",
                "three/addons/": "./three.js-dev/examples/jsm/"
            }
        }
    </script>

    <script type="module">

import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { HDRLoader } from '../src/loaders/HDRLoader.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { Sky } from 'three/addons/objects/Sky.js';

let camera, scene, renderer, controls;
let forestGroup; // 树林组合组
let treePositions = []; // 树木位置数组
let sky, sun; // 天空和太阳对象

// 全局调试参数（保留基础参数）
window.debugParams = {
	heightOffset: -11.0  // 全局高度偏移
};

init();

// 初始化函数
async function init() {
	const container = document.createElement('div');
	document.body.appendChild(container);

	// 创建相机
	camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 100);
	camera.position.set(-15, 8, 15); // 更高的位置，俯视整个森林

	// 创建场景
	scene = new THREE.Scene();

	// 创建树林组合组
	forestGroup = new THREE.Group();
	forestGroup.name = 'forest';

	// 生成随机树林
	generateForest();

	// 生成地面扭曲线条
	createTwistingJitterLine();

	// 添加测试模型
	addTestModel();

	// 加载 HDR 环境照明
	const hdrLoader = new HDRLoader().setPath('./hdr/');

	// 加载环境照明贴图
	hdrLoader.load('royal_esplanade_1k.hdr',
		function (envTexture) {
			envTexture.mapping = THREE.EquirectangularReflectionMapping;
			// 不设置 scene.environment，让天空作为背景
			// scene.environment = envTexture; // 仅用于环境照明

			// 不设置固定的背景颜色，让天空作为背景
			// scene.background = new THREE.Color(lightGray);

			render();
		},
		function (progress) {
			// 可以在这里显示加载进度，但暂时保持简单
		},
		function (error) {
			console.error('HDR加载失败:', error);
			// 设置默认背景（如果天空不可用）
			const lightGray = 0xcccccc;
			scene.background = new THREE.Color(lightGray);
			render();
		}
	);

	// 创建渲染器
	renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	renderer.toneMapping = THREE.ACESFilmicToneMapping;
	renderer.toneMappingExposure = 1;
	container.appendChild(renderer.domElement);

	// 初始化天空
	initSky();

	// 添加环境光照和雾效果
	addLightingAndFog();

	// 添加控制器
	controls = new OrbitControls(camera, renderer.domElement);
	controls.addEventListener('change', render);
	controls.minDistance = 5;
	controls.maxDistance = 50;
	controls.target.set(0, 5, 0); // 看向森林中央稍微高一点的位置
	controls.update();

	window.addEventListener('resize', onWindowResize);

	// 创建控制面板
	createControlPanel();

	// 添加键盘快捷键监听器（按键1切换控制面板显示/隐藏）
	window.addEventListener('keydown', (event) => {
		if (event.key === '1') {
			toggleControlPanel();
		}
	});
}

// 初始化天空 (使用 Ocean 示例的光照系统)
function initSky() {

	// Add Sky
	sky = new Sky();
	sky.scale.setScalar(450000);
	// scene.add(sky); // 先不添加到场景，后续通过 PMREM 添加

	sun = new THREE.Vector3();

	// Ocean 风格的光照参数 + 色调映射参数
	const effectController = {
		// 天空参数
		turbidity: 10,
		rayleigh: 2,
		mieCoefficient: 0.005,
		mieDirectionalG: 0.8,
		elevation: 2,
		azimuth: 180,
		// 色调映射参数 (来自 webgl_tonemapping)
		toneMapping: 'ACESFilmic',
		exposure: renderer.toneMappingExposure,
		blurriness: 0.3,
		intensity: 1.0
	};

	// 色调映射选项 (来自 webgl_tonemapping)
	const toneMappingOptions = {
		None: THREE.NoToneMapping,
		Linear: THREE.LinearToneMapping,
		Reinhard: THREE.ReinhardToneMapping,
		Cineon: THREE.CineonToneMapping,
		ACESFilmic: THREE.ACESFilmicToneMapping,
		AgX: THREE.AgXToneMapping,
		Neutral: THREE.NeutralToneMapping,
		Custom: THREE.CustomToneMapping
	};

	// PMREM 生成器 (来自 Ocean 示例)
	const pmremGenerator = new THREE.PMREMGenerator(renderer);
	const sceneEnv = new THREE.Scene();

	let renderTarget;

	// 存储引用以便清理
	window.pmremGenerator = pmremGenerator;
	window.sceneEnv = sceneEnv;

	function updateSun() {

		const phi = THREE.MathUtils.degToRad(90 - effectController.elevation);
		const theta = THREE.MathUtils.degToRad(effectController.azimuth);

		sun.setFromSphericalCoords(1, phi, theta);

		// 更新天空 uniforms
		const uniforms = sky.material.uniforms;
		uniforms['turbidity'].value = effectController.turbidity;
		uniforms['rayleigh'].value = effectController.rayleigh;
		uniforms['mieCoefficient'].value = effectController.mieCoefficient;
		uniforms['mieDirectionalG'].value = effectController.mieDirectionalG;
		uniforms['sunPosition'].value.copy(sun);

		// 清理旧的 renderTarget
		if (renderTarget !== undefined) renderTarget.dispose();

		// 创建天空的 PMREM 环境贴图 (Ocean 方式)
		sceneEnv.add(sky);
		renderTarget = pmremGenerator.fromScene(sceneEnv);
		// 移除天空从临时场景，避免重复渲染
		if (sceneEnv.children.includes(sky)) {
			sceneEnv.remove(sky);
		}

		// 将天空添加到主场景
		if (!scene.children.includes(sky)) {
			scene.add(sky);
		}

		// 设置场景环境贴图 (关键：使用 PMREM 环境照明)
		scene.environment = renderTarget.texture;

		// 更新光照位置以配合天空
		updateLightingFromSky();

		renderer.toneMappingExposure = effectController.exposure;
		renderer.render(scene, camera);

	}

	// 设置 Custom 色调映射 (来自 webgl_tonemapping 示例)
	// Set CustomToneMapping to Uncharted2
	// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
	THREE.ShaderChunk.tonemapping_pars_fragment = THREE.ShaderChunk.tonemapping_pars_fragment.replace(

		'vec3 CustomToneMapping( vec3 color ) { return color; }',

		`#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )

		float toneMappingWhitePoint = 1.0;

		vec3 CustomToneMapping( vec3 color ) {
			color *= toneMappingExposure;
			return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );

		}`

	);

	// 设置初始色调映射
	renderer.toneMapping = toneMappingOptions[effectController.toneMapping];
	renderer.toneMappingExposure = effectController.exposure;
	scene.backgroundBlurriness = effectController.blurriness;
	scene.backgroundIntensity = effectController.intensity;

	// 初始更新
	updateSun();

	// 将天空控制添加到现有的控制面板
	setTimeout(() => {
		const statsDiv = document.getElementById('sceneStats');
		if (statsDiv) {
			statsDiv.innerHTML += `
				<br><br>
				<strong>Sky Controls:</strong><br>
				<label>Turbidity: <input type="range" id="turbiditySlider" min="0.0" max="20.0" step="0.1" value="10">
				<span id="turbidityValue">10</span></label><br>

				<label>Rayleigh: <input type="range" id="rayleighSlider" min="0.0" max="4.0" step="0.001" value="3">
				<span id="rayleighValue">3</span></label><br>

				<label>Mie Coeff: <input type="range" id="mieCoeffSlider" min="0.0" max="0.1" step="0.001" value="0.005">
				<span id="mieCoeffValue">0.005</span></label><br>

				<label>Mie Dir G: <input type="range" id="mieDirGSlider" min="0.0" max="1.0" step="0.001" value="0.7">
				<span id="mieDirGValue">0.7</span></label><br>

				<label>Elevation: <input type="range" id="elevationSlider" min="0" max="90" step="0.1" value="2">
				<span id="elevationValue">2</span></label><br>

				<label>Azimuth: <input type="range" id="azimuthSlider" min="-180" max="180" step="0.1" value="180">
				<span id="azimuthValue">180</span></label><br>

				<label>Exposure: <input type="range" id="exposureSlider" min="0" max="1" step="0.0001" value="${renderer.toneMappingExposure}">
				<span id="exposureValue">${renderer.toneMappingExposure}</span></label><br>
			`;

			// 添加事件监听器 - 天空参数
			const skySliders = ['turbidity', 'rayleigh', 'mieCoeff', 'mieDirG', 'elevation', 'azimuth'];
			skySliders.forEach(slider => {
				const sliderEl = document.getElementById(slider + 'Slider');
				const valueEl = document.getElementById(slider + 'Value');
				if (sliderEl && valueEl) {
					sliderEl.addEventListener('input', (e) => {
						const value = parseFloat(e.target.value);
						effectController[slider === 'mieCoeff' ? 'mieCoefficient' : slider === 'mieDirG' ? 'mieDirectionalG' : slider] = value;
						valueEl.textContent = value.toFixed((slider === 'rayleigh' || slider === 'mieCoeff' || slider === 'mieDirG') ? 3 : 1);
						updateSun();
					});
				}
			});

			// 添加事件监听器 - 色调映射参数
			const toneMappingSelect = document.getElementById('toneMappingSelect');
			if (toneMappingSelect) {
				toneMappingSelect.addEventListener('change', (e) => {
					effectController.toneMapping = e.target.value;
					renderer.toneMapping = toneMappingOptions[effectController.toneMapping];
					updateToneMappingGUI();
					renderer.render(scene, camera);
				});
			}

			const toneMappingSliders = ['exposure', 'blurriness', 'intensity'];
			toneMappingSliders.forEach(slider => {
				const sliderEl = document.getElementById(slider + 'Slider');
				const valueEl = document.getElementById(slider + 'Value');
				if (sliderEl && valueEl) {
					sliderEl.addEventListener('input', (e) => {
						const value = parseFloat(e.target.value);
						effectController[slider] = value;
						valueEl.textContent = value.toFixed(2);

						// 更新相应的渲染器/场景属性
						if (slider === 'exposure') {
							renderer.toneMappingExposure = value;
						} else if (slider === 'blurriness') {
							scene.backgroundBlurriness = value;
						} else if (slider === 'intensity') {
							scene.backgroundIntensity = value;
						}

						renderer.render(scene, camera);
					});
				}
			});

			// 添加 FBX 方向光控制事件监听器
			const fbxLightSliders = ['fbxDirLightIntensity'];
			fbxLightSliders.forEach(slider => {
				const sliderEl = document.getElementById(slider + 'Slider');
				const valueEl = document.getElementById(slider + 'Value');
				if (sliderEl && valueEl) {
					sliderEl.addEventListener('input', (e) => {
						const value = parseFloat(e.target.value);
						valueEl.textContent = value.toFixed(1);

						// 更新 FBX 方向光强度
						if (window.sceneLights && window.sceneLights.dirLight) {
							window.sceneLights.dirLight.intensity = value;
						}

						renderer.render(scene, camera);
					});
				}
			});
		}

		// 更新色调映射GUI状态
		updateToneMappingGUI();

		updateSun();

	}, 100);

}

// 创建控制面板
function createControlPanel() {
	const panel = document.createElement('div');
	panel.id = 'controlPanel';
	panel.style.position = 'absolute';
	panel.style.top = '10px';
	panel.style.right = '10px';
	panel.style.background = 'rgba(0,0,0,0.8)';
	panel.style.color = 'white';
	panel.style.padding = '15px';
	panel.style.borderRadius = '8px';
	panel.style.fontFamily = 'monospace';
	panel.style.fontSize = '12px';
	panel.style.zIndex = '100';
	// 默认隐藏
	panel.style.display = 'none';

	panel.innerHTML = `
		<strong>Scene Control</strong><br><br>
		<label>Height Offset: <span id="heightOffsetValue">-11.0</span></label><br>
		<input type="range" id="heightOffsetSlider" min="-20.0" max="20.0" step="0.5" value="-11.0"><br><br>

		<strong>Tone Mapping Controls</strong><br><br>
		<label>Tone Mapping: <select id="toneMappingSelect">
			<option value="None">None</option>
			<option value="Linear">Linear</option>
			<option value="Reinhard">Reinhard</option>
			<option value="Cineon">Cineon</option>
			<option value="ACESFilmic" selected>ACESFilmic</option>
			<option value="AgX">AgX</option>
			<option value="Neutral">Neutral</option>
			<option value="Custom">Custom</option>
		</select></label><br>

		<label>Exposure: <input type="range" id="exposureSlider" min="0" max="2" step="0.01" value="0.5">
		<span id="exposureValue">0.5</span></label><br>

		<label>Background Blurriness: <input type="range" id="blurrinessSlider" min="0" max="1" step="0.01" value="0.3">
		<span id="blurrinessValue">0.3</span></label><br>

		<label>Background Intensity: <input type="range" id="intensitySlider" min="0" max="1" step="0.01" value="1.0">
		<span id="intensityValue">1.0</span></label><br><br>

		<strong>FBX Lighting Controls</strong><br><br>
		<label>FBX Dir Light Intensity: <input type="range" id="fbxDirLightIntensitySlider" min="0" max="15" step="0.1" value="8">
		<span id="fbxDirLightIntensityValue">8</span></label><br><br>

		<div id="sceneStats">
			Loading...
		</div>
	`;

	// 添加滑块事件监听
	setTimeout(() => {
		const slider = document.getElementById('heightOffsetSlider');
		const valueSpan = document.getElementById('heightOffsetValue');

		if (slider && valueSpan) {
			slider.addEventListener('input', (e) => {
				const value = parseFloat(e.target.value);
				window.debugParams.heightOffset = value;
				valueSpan.textContent = value.toFixed(1);
			});
		}
	}, 100);

	document.body.appendChild(panel);

	// 切换控制面板显示/隐藏
	window.toggleControlPanel = function() {
		const panel = document.getElementById('controlPanel');
		if (panel) {
			const isHidden = panel.style.display === 'none';
			panel.style.display = isHidden ? 'block' : 'none';
			console.log('Control Panel:', isHidden ? 'Shown' : 'Hidden');
		}
	};
}

// 更新色调映射GUI状态 (来自 webgl_tonemapping 示例)
function updateToneMappingGUI() {
	const exposureSlider = document.getElementById('exposureSlider');
	const exposureLabel = exposureSlider ? exposureSlider.parentElement : null;

	if (effectController.toneMapping === 'None') {
		if (exposureLabel) exposureLabel.style.display = 'none';
	} else {
		if (exposureLabel) exposureLabel.style.display = 'block';
	}
}

// 更新场景统计信息
function updateSceneStats() {
	const statsDiv = document.getElementById('sceneStats');
	if (!statsDiv) return;

	const trees = treePositions.length;

	statsDiv.innerHTML = `
		Trees: ${trees}<br>
		Test Model: Belly Component (belly (1).glb, 5x scale)<br>
		Sky: Ocean-style PMREM Environment Lighting<br>
		Tone Mapping: ${effectController.toneMapping}<br>
		Lighting: FBX DirLight + Ocean Directional + Ambient<br>
		Shadows: Enabled (Renderer + Models + Ground)<br>
		Scene: Forest with Dynamic Sky Environment
	`;
}

// ===================== 创建噪波地面材质 =====================
function createNoiseGround() {
	console.log('Creating noise-based ground with irregular displacement...');

	// 创建大的地面几何体
	const geometry = new THREE.PlaneGeometry(60, 60, 256, 256);
	geometry.rotateX(-Math.PI / 2); // 水平放置

	// 自定义着色器材质，实现静态随机噪波起伏
	const material = new THREE.ShaderMaterial({
		uniforms: {
			amplitude: { value: 3.0 }  // 起伏幅度
		},
		vertexShader: `
			uniform float amplitude;

			// 简化的噪声函数 - 基于位置生成静态随机值
			float hash(vec2 p) {
				return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
			}

			float noise(vec2 p) {
				vec2 i = floor(p);
				vec2 f = fract(p);
				f = f * f * (3.0 - 2.0 * f);

				float a = hash(i);
				float b = hash(i + vec2(1.0, 0.0));
				float c = hash(i + vec2(0.0, 1.0));
				float d = hash(i + vec2(1.0, 1.0));

				return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
			}

			// 多层噪声叠加
			float fbm(vec2 p) {
				float value = 0.0;
				float amplitude = 1.0;
				float frequency = 0.01;

				for(int i = 0; i < 5; i++) {
					value += amplitude * noise(p * frequency);
					amplitude *= 0.5;
					frequency *= 2.0;
				}

				return value;
			}

			void main() {
				vec3 pos = position;

				// 生成静态随机噪波起伏
				float noiseValue = fbm(pos.xz);
				float displacement = (noiseValue - 0.5) * amplitude;

				// 应用位移
				pos.y += displacement;

				gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
			}
		`,
		fragmentShader: `
			void main() {
				// 半透明浅灰色地面
				vec3 color = vec3(0.7, 0.7, 0.7);
				gl_FragColor = vec4(color, 0.3);
			}
		`,
		side: THREE.DoubleSide
	});

	const ground = new THREE.Mesh(geometry, material);
	ground.position.y = -2; // 稍微下沉
	ground.receiveShadow = true;

	// 添加到场景
	forestGroup.add(ground);

	// 存储材质引用用于动画更新
	ground.userData.material = material;

	console.log('Noise-based ground created with fractal displacement');

	return ground;
}

// ===================== 生成90根延长树枝 =====================
function generateForest() {
	console.log('Creating 90 randomly distributed black curves...');

	const totalCurves = 90;
	const maxRadius = 25; // 圆形区域的最大半径
	const treeBaseRadius = 0.12; // 树干底部半径
	const minDistance = treeBaseRadius * 3; // 最小间距：1.5倍树干宽度（直径的两倍）

	// 清空全局树木位置数组，为新的森林生成做准备
	treePositions.length = 0;

	for (let curveIndex = 0; curveIndex < totalCurves; curveIndex++) {
		// 创建分段管状几何体 - 越向上越细
		const segments = 4 + Math.floor(Math.random() * 7); // 随机分成4-10段
		const group = new THREE.Group();

		// 在圆形区域内随机分布，确保最小间距
		let xOffset, zOffset, attempts = 0;
		do {
			const randomAngle = Math.random() * Math.PI * 2; // 随机角度 0-360°
			const randomRadius = Math.random() * maxRadius; // 随机半径 0-maxRadius
			xOffset = Math.cos(randomAngle) * randomRadius;
			zOffset = Math.sin(randomAngle) * randomRadius;
			attempts++;
		} while (attempts < 50 && treePositions.some(pos =>
			Math.sqrt((pos.x - xOffset) ** 2 + (pos.z - zOffset) ** 2) < minDistance
		));

		// 如果找不到合适位置，使用螺旋分布作为fallback
		if (attempts >= 50) {
			const angle = (curveIndex / totalCurves) * Math.PI * 4; // 4圈螺旋
			const radius = (angle / (Math.PI * 4)) * maxRadius;
			xOffset = Math.cos(angle) * radius;
			zOffset = Math.sin(angle) * radius;
		}

		// 创建该根曲线的路径点
		const points = [];
		const height = 10 + Math.random() * 10; // 随机总高度 10-20
		const baseAmplitude = 0.3; // 进一步减小振幅，几乎垂直向上

		// 生成轻微随机偏折的路径，从地平面(y=-1)开始
		for (let i = 0; i <= 200; i++) {
			const t = i / 200; // 归一化参数 0-1
			const y = -1 + t * height; // 从地平面(y=-1)开始生长到height

			// 极轻微的随机偏折 - 最小化横向偏移
			const randomX = Math.sin(t * Math.PI + Math.random() * Math.PI * 0.5) * baseAmplitude;
			const randomZ = Math.cos(t * Math.PI * 1.3 + Math.random() * Math.PI * 0.5) * baseAmplitude;

			// 几乎不添加额外噪声，保持最小偏折
			const x = (randomX * 0.95) + xOffset;
			const z = (randomZ * 0.95) + zOffset;

			points.push(new THREE.Vector3(x, y, z));
		}

		// 创建平滑曲线
		const curve = new THREE.CatmullRomCurve3(points);

		for (let i = 0; i < segments; i++) {
			const t1 = i / segments;
			const t2 = (i + 1) / segments;

			// 获取曲线段的起点和终点
			const point1 = curve.getPointAt(t1);
			const point2 = curve.getPointAt(t2);

			// 计算该段的半径（越向上越小，从0.12渐变到0.03）
			const baseRadius = 0.12;
			const minRadius = 0.03;
			const radius = baseRadius - (baseRadius - minRadius) * (i / segments);

			// 创建短线段
			const segmentPoints = [point1, point2];
			const segmentCurve = new THREE.CatmullRomCurve3(segmentPoints);
			const segmentGeometry = new THREE.TubeGeometry(segmentCurve, 2, radius, 8, false);

			const material = new THREE.MeshBasicMaterial({
				color: 0x000000,
				transparent: true,
				opacity: 0.8,
				wireframe: true
			});

			const segment = new THREE.Mesh(segmentGeometry, material);
			group.add(segment);
		}

		// 存储树干信息用于鸟类定位
		treePositions.push({
			position: new THREE.Vector3(xOffset, height, zOffset),
			height: height,
			tree: group,
			scale: 1
		});

		forestGroup.add(group);
	}

	// 添加树林到场景
	scene.add(forestGroup);
	console.log('90 randomly distributed black curves created');

	// 更新统计信息
	updateSceneStats();
}

// ===================== 创建扭曲抖动线条 =====================
function createTwistingJitterLine() {
	console.log('Creating 40 smooth twisting jitter thick lines on ground...');

	const totalLines = 40; // 生成40条线条
	const maxRadius = 25; // 分布区域的最大半径

	for (let lineIndex = 0; lineIndex < totalLines; lineIndex++) {
		const lineGroup = new THREE.Group();
		const numPoints = 200; // 总点数，增加以获得更平滑的曲线
		const lineRadius = 0.3; // 线条半径（粗细）- 粗线条
		const overlapPoints = 3; // 重叠点数，确保分段连接平滑

		// 在圆形区域内随机分布线条位置
		const randomAngle = Math.random() * Math.PI * 2; // 随机角度 0-360°
		const randomRadius = Math.random() * maxRadius; // 随机半径 0-maxRadius
		const xOffset = Math.cos(randomAngle) * randomRadius;
		const zOffset = Math.sin(randomAngle) * randomRadius;

		// 生成扭曲抖动的路径点
		const points = [];
		for (let i = 0; i <= numPoints; i++) {
			const t = i / numPoints; // 0到1的参数
			const x = (t - 0.5) * 60 + xOffset; // 水平方向从-30到30 - 长度增加一倍

			// 创建柔和的抖动和扭曲效果 - 降低幅度避免纠缠
			const baseWave = Math.sin(t * Math.PI * 4) * 1.5; // 基础波形 - 幅度减半
			const jitter1 = Math.sin(t * Math.PI * 12 + Math.random() * Math.PI * 2) * 0.3; // 高频抖动 - 幅度降低
			const jitter2 = Math.cos(t * Math.PI * 8 + Math.random() * Math.PI * 2) * 0.2; // 中频抖动 - 幅度降低
			const twist = Math.sin(t * Math.PI * 6) * Math.cos(t * Math.PI * 3) * 0.5; // 扭曲效果 - 幅度降低

			const y = baseWave + jitter1 + jitter2 + twist;

			// Z方向的抖动 - 同样降低幅度
			const zJitter1 = Math.sin(t * Math.PI * 10 + Math.random() * Math.PI * 2) * 0.25;
			const zJitter2 = Math.cos(t * Math.PI * 14 + Math.random() * Math.PI * 2) * 0.15;
			const zTwist = Math.cos(t * Math.PI * 5) * Math.sin(t * Math.PI * 7) * 0.4;

			const z = zJitter1 + zJitter2 + zTwist + zOffset;

			points.push(new THREE.Vector3(x, y, z));
		}

		// 创建连续的管状分段，使用重叠点确保平滑连接
		const segmentSize = 20; // 每个分段包含的点数
		for (let i = 0; i < points.length - segmentSize; i += segmentSize - overlapPoints) {
			// 提取当前分段的点
			const segmentPoints = [];
			const endIndex = Math.min(i + segmentSize, points.length);
			for (let j = i; j < endIndex; j++) {
				segmentPoints.push(points[j]);
			}

			// 至少需要2个点才能创建曲线
			if (segmentPoints.length >= 2) {
				const curve = new THREE.CatmullRomCurve3(segmentPoints);

				// 创建管状几何体，增加tubularSegments以获得更平滑的表面
				const radius = lineRadius;
				const geometry = new THREE.TubeGeometry(curve, segmentPoints.length * 2, radius, 12, false);

				// 创建黑色材质
				const material = new THREE.MeshBasicMaterial({
					color: 0x000000, // 黑色
					transparent: true,
					opacity: 0.9
				});

				const tube = new THREE.Mesh(geometry, material);
				lineGroup.add(tube);
			}
		}

		// 设置线条位置 - 悬浮在虚空中的水平面位置
		lineGroup.position.set(0, 0, 0); // 虚空水平面位置

		// 添加到场景
		forestGroup.add(lineGroup);
	}

	console.log('40 smooth twisting jitter thick black lines created on ground');

	return;
}

// 添加光照和雾效果 (Ocean 风格)
function addLightingAndFog() {
		// 添加淡灰色雾效果
		const lightGray = 0xcccccc;
		scene.fog = new THREE.Fog(lightGray, 20, 50);

	// Ocean 风格的光照：主要依赖环境照明，减少直接光照
	// 环境光 - 提供基础照明
	const ambientLight = new THREE.AmbientLight(0x404040, 0.2); // 增加强度
	forestGroup.add(ambientLight);

	// 主方向光（模拟阳光，与天空太阳位置同步，Ocean 风格）
	const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0); // 显著增加强度
	directionalLight.position.set(100, 100, 50); // 设置固定位置确保可见
	directionalLight.castShadow = true;

	// 配置阴影 - Ocean 风格的高质量阴影
	directionalLight.shadow.mapSize.width = 2048;
	directionalLight.shadow.mapSize.height = 2048;
	directionalLight.shadow.camera.near = 0.5;
	directionalLight.shadow.camera.far = 50;
	directionalLight.shadow.camera.left = -30;
	directionalLight.shadow.camera.right = 30;
	directionalLight.shadow.camera.top = 30;
	directionalLight.shadow.camera.bottom = -30;

	// 改善阴影质量
	directionalLight.shadow.bias = -0.0001;
	directionalLight.shadow.radius = 4;

	forestGroup.add(directionalLight);

	// FBX 风格的方向光 (来自 webgl_loader_fbx 示例)
	const dirLight = new THREE.DirectionalLight(0xffffff, 8); // 增加强度
	dirLight.position.set(0, 200, 100);
	dirLight.castShadow = true;
	dirLight.shadow.camera.top = 180;
	dirLight.shadow.camera.bottom = -100;
	dirLight.shadow.camera.left = -120;
	dirLight.shadow.camera.right = 120;
	forestGroup.add(dirLight);

	// 补充光源 - Ocean 风格的微弱填充光
	const fillLight = new THREE.DirectionalLight(0x87CEEB, 0.1); // 进一步降低
	fillLight.position.set(-5, 10, -5);
	forestGroup.add(fillLight);

	// 地面阴影接收 (来自 FBX 示例)
	const groundMesh = new THREE.Mesh(
		new THREE.PlaneGeometry(2000, 2000),
		new THREE.MeshPhongMaterial({ color: 0x999999, depthWrite: false })
	);
	groundMesh.rotation.x = -Math.PI / 2;
	groundMesh.receiveShadow = true;
	groundMesh.position.y = -2; // 放在噪波地面下方
	forestGroup.add(groundMesh);

	// 存储光照引用以便后续更新
	window.sceneLights = {
		directionalLight,
		dirLight,
		ambientLight,
		fillLight
	};
}

// 更新光照位置以配合天空太阳
function updateLightingFromSky() {
	if (window.sceneLights && window.sceneLights.directionalLight && sun) {
		// 将太阳位置复制到主方向光
		window.sceneLights.directionalLight.position.copy(sun).multiplyScalar(100);
	}
}

// 添加测试模型
function addTestModel() {
	// 直接加载 belly (1).glb 文件
	const gltfLoader = new GLTFLoader();

	gltfLoader.load('/models/bird_components/belly/belly (1).glb',
		(gltf) => {
			const testModel = gltf.scene;

			// 应用材质预处理 - 使用更安全的方法
			testModel.traverse((child) => {
				if (child.isMesh && child.material) {
					try {
						// 简化材质处理：创建一个全新的标准材质
						const newMaterial = new THREE.MeshStandardMaterial({
							color: 0x888888, // 默认颜色
							roughness: 0.2,  // 降低粗糙度，增加光滑度
							metalness: 0.8   // 增加金属度，产生明显高光
						});

						// 尝试复制一些基本属性
						const originalMaterial = Array.isArray(child.material) ? child.material[0] : child.material;

						if (originalMaterial && originalMaterial.color && originalMaterial.color.isColor) {
							newMaterial.color.copy(originalMaterial.color);
						}

						// 复制纹理贴图（如果存在且有效）
						if (originalMaterial.map && originalMaterial.map.isTexture) {
							newMaterial.map = originalMaterial.map;
						}
						if (originalMaterial.normalMap && originalMaterial.normalMap.isTexture) {
							newMaterial.normalMap = originalMaterial.normalMap;
						}
						if (originalMaterial.roughnessMap && originalMaterial.roughnessMap.isTexture) {
							newMaterial.roughnessMap = originalMaterial.roughnessMap;
						}
						if (originalMaterial.metalnessMap && originalMaterial.metalnessMap.isTexture) {
							newMaterial.metalnessMap = originalMaterial.metalnessMap;
						}

						// 设置材质属性
						if (typeof originalMaterial.roughness === 'number') {
							newMaterial.roughness = Math.max(0, Math.min(1, originalMaterial.roughness));
						}
						if (typeof originalMaterial.metalness === 'number') {
							newMaterial.metalness = Math.max(0, Math.min(1, originalMaterial.metalness));
						}

						child.material = newMaterial;

					} catch (error) {
						console.warn('材质处理失败，使用默认材质:', error);
						child.material = new THREE.MeshStandardMaterial({
							color: 0xff6b6b,
							roughness: 0.1,  // 更光滑
							metalness: 0.9  // 更金属，产生明显高光
						});
					}
				}
			});

			testModel.scale.set(5, 5, 5); // 5倍大小
			testModel.position.set(0, 3, 0); // 放在场景中心稍微高一点的位置

			// 设置阴影 (FBX 示例风格)
			testModel.traverse(function (child) {
				if (child.isMesh) {
					child.castShadow = true;
					child.receiveShadow = true;
				}
			});

			// 添加到场景
			forestGroup.add(testModel);

			console.log('Belly component (belly (1).glb) added to scene at (0, 3, 0) with 5x scale');
		},
		(progress) => {
			console.log('Loading belly model...', (progress.loaded / progress.total * 100) + '%');
		},
		(error) => {
			console.error('Failed to load belly model:', error);

			// 回退到立方体
			const geometry = new THREE.BoxGeometry(2, 2, 2);
			const material = new THREE.MeshStandardMaterial({
				color: 0xff6b6b,
				roughness: 0.3,
				metalness: 0.1
			});

			const testModel = new THREE.Mesh(geometry, material);
			testModel.scale.set(5, 5, 5);
			testModel.position.set(0, 3, 0);

			testModel.castShadow = true;
			testModel.receiveShadow = true;

			forestGroup.add(testModel);
			console.log('Fallback cube added due to model loading failure');
		}
	);
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
	render();
}

function render() {
	if (renderer) {
		renderer.render(scene, camera);
	}
}

// 添加清理事件监听器
window.addEventListener('beforeunload', () => {
	if (window.pmremGenerator) {
		window.pmremGenerator.dispose();
	}
});

// 启动动画循环
animate();

function animate() {
	requestAnimationFrame(animate);

	// 只有在controls初始化后才更新
	if (controls) {
		controls.update();
	}
	render();
}

    </script>
</body>
</html>